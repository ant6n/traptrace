import json

# will generate a c file that provides functions that can print syscalls
# from the syscall json file

# format of the json is a dictionary where 'aaData' contains an array of syscalls,
# each specified as an array with the following entries:
# - number
# - name
# - arg-types
# - eax (syscall number)
# - input1 ebx
# - input2 ecx
# - input3 edx
# - input4 esi
# - input5 edi
# - source file
# - line


# given a c definition, splits it into type and variable name
# if it is a pointer type (i.e. includes *), it will be associated
# with the type
def splitDefinition(definition):
    if "*" in definition:
        tokens = definition.split('*')
        name = tokens[-1].strip()
        type = "*".join(t.strip() for t in tokens[:-1]) + "*"
    else:
        tokens = definition.strip().split(' ')
        name = tokens[-1]
        type = ' '.join(tokens[:-1]).strip()
    return {
        'type': type,
        'name': name,
    }
        

def printArgument(d, reg, indent):
    if 'char' in d['type'] and '*' in d['type']:
        maxLength = 60
        return """
{indent}writeStr("\\"");
{indent}writeStrEscapedMaxNumChars((const char*){reg});
{indent}writeStr("\\"");
""".format(indent=indent, reg=reg, maxLength=maxLength)
    if ('unsigned' in d['type'] or 'int' in d['type']) and '*' not in d['type']:
        return (
            #indent + 'writeStr("%s = ");\n' % d['name']
            indent+ 'writeInt(%s);\n' % reg
        )
        
    else:
        return (
            #indent + 'writeStr("%s = ");\n' % d['name']
            indent+ 'writeHex(%s);\n' % reg
        )


def printSyscallCode(syscalls):
    result = """
#include "helper.h"
#include <unistd.h>

// generated by makesyscallprinter.py, to print syscalls

static void writeStrEscapedMaxNumChars(const char* c) {
    static const int N = 60;
    char buffer[N+5];
    char* t = buffer;
    int numChars = 0;
    while (numChars < N && c != '\\0') {
        *t++ = *c++;
        numChars++;
    }
    if (c != '\\0') {
        *t++ = '.';
        *t++ = '.';
        *t++ = '.';
    }
    *t++ = '\\0';
    writeStrEscaped(buffer);
}

void printSyscall(long eax, long ebx, long ecx, long edx, long esi, long edi) {
    switch (eax) {
    """
    argRegs = ['ebx', 'ecx', 'edx', 'esi', 'edi']
    for entry in syscalls:
        number = entry[0]
        name = entry[1]
        inputs = [
            splitDefinition(s.strip())
            for s in entry[2].replace('(', '').replace(')', '').strip().split(',')
        ]
        result += '        case 0x%x: { // %d\n' % (number, number)
        result += '            //%d: %s(%s)\n' % (number, name,
                                                  ", ".join(d['type'] + " " + d['name']
                                                            for d in inputs))
        result += '            writeStr("%s(");\n' % name
        for i, d in enumerate(inputs[:5]):
            result += printArgument(d, argRegs[i], '            ')
            if i < len(inputs) - 1:
                result += '            writeStr(", ");\n'
        if len(inputs) > 5:
            result += '            writeStr("...");\n'
            
        result += '            writeStr(")\\n");\n'
        result += '            break;\n'
        result += '        }\n'
    result += """
        default: {
            writeStr("unknown_call_0x");
            writeHex(eax);
            writeStr("(eax=");
            writeHex(eax);
            writeStr(", ebx=");
            writeHex(ebx);
            writeStr(", ecx=");
            writeHex(ecx);
            writeStr(", edx=");
            writeHex(edx);
            writeStr(", esi=");
            writeHex(esi);
            writeStr(", edi=");
            writeHex(edi);
            writeStr(")\\n");
            break;
        }
    }
}
"""
    return result


data = json.load(open("syscalls-2.6.35.4.js"))
code = printSyscallCode(data['aaData'])
print code
with open("../syscallprinter.c", "w") as f:
    f.write(code)
