import json

# will generate a c file that provides functions that can print syscalls
# from the syscall json file

# format of the json is a dictionary where 'aaData' contains an array of syscalls,
# each specified as an array with the following entries:
# - number
# - name
# - arg-types
# - eax (syscall number)
# - input1 ebx
# - input2 ecx
# - input3 edx
# - input4 esi
# - input5 edi
# - source file
# - line


# given a c definition, splits it into type and variable name
# if it is a pointer type (i.e. includes *), it will be associated
# with the type
def splitDefinition(definition):
    if "*" in definition:
        tokens = definition.split('*')
        name = tokens[-1].strip()
        type = "*".join(t.strip() for t in tokens[:-1]) + "*"
    else:
        tokens = definition.strip().split(' ')
        name = tokens[-1]
        type = ' '.join(tokens[:-1]).strip()
    return {
        'type': type,
        'name': name,
    }
        

def printArgument(d, reg, indent):
    if 'char' in d['type'] and '*' in d['type']:
        maxLength = 60
        return """
{indent}fwriteStr(f, "\\"");
{indent}fwriteStrEscapedMaxNumChars(f, (const char*){reg});
{indent}fwriteStr(f, "\\"");
""".format(indent=indent, reg=reg, maxLength=maxLength)
    if ('unsigned' in d['type'] or 'int' in d['type']) and '*' not in d['type']:
        return (
            indent+ 'fwriteInt(f, %s);\n' % reg
        )
        
    else:
        return (
            indent+ 'fwriteHex(f, %s);\n' % reg
        )


def printSyscallCode(syscalls):
    result = """
#include "helper.h"
#include <unistd.h>

// generated by makesyscallprinter.py, to print syscalls

static void fwriteStrEscapedMaxNumChars(int f, const char* c) {
    static const int N = 60;
    char buffer[N+5];
    char* t = buffer;
    int numChars = 0;
    while (numChars < N && c != '\\0') {
        *t++ = *c++;
        numChars++;
    }
    if (c != '\\0') {
        *t++ = '.';
        *t++ = '.';
        *t++ = '.';
    }
    *t++ = '\\0';
    fwriteStrEscaped(f, buffer);
}

void fwrite_syscall(int f, long eax, long ebx, long ecx, long edx, long esi, long edi) {
    switch (eax) {
    """
    argRegs = ['ebx', 'ecx', 'edx', 'esi', 'edi']
    for entry in syscalls:
        number = entry[0]
        name = entry[1]
        inputs = [
            splitDefinition(s.strip())
            for s in entry[2].replace('(', '').replace(')', '').strip().split(',')
        ]
        result += '        case 0x%x: { // %d\n' % (number, number)
        result += '            //%d: %s(%s)\n' % (number, name,
                                                  ", ".join(d['type'] + " " + d['name']
                                                            for d in inputs))
        result += '            fwriteStr(f, "%s(");\n' % name
        for i, d in enumerate(inputs[:5]):
            result += printArgument(d, argRegs[i], '            ')
            if i < len(inputs) - 1:
                result += '            fwriteStr(f, ", ");\n'
        if len(inputs) > 5:
            result += '            fwriteStr(f, "...");\n'
            
        result += '            fwriteStr(f, ")\\n");\n'
        result += '            break;\n'
        result += '        }\n'
    result += """
        default: {
            fwriteStr(f, "unknown_call_0x");
            fwriteHex(f, eax);
            fwriteStr(f, "(eax=");
            fwriteHex(f, eax);
            fwriteStr(f, ", ebx=");
            fwriteHex(f, ebx);
            fwriteStr(f, ", ecx=");
            fwriteHex(f, ecx);
            fwriteStr(f, ", edx=");
            fwriteHex(f, edx);
            fwriteStr(f, ", esi=");
            fwriteHex(f, esi);
            fwriteStr(f, ", edi=");
            fwriteHex(f, edi);
            fwriteStr(f, ")\\n");
            break;
        }
    }
}
"""
    return result


data = json.load(open("syscalls-2.6.35.4.js"))
code = printSyscallCode(data['aaData'])
print code
with open("../syscallprinter.c", "w") as f:
    f.write(code)
